<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Spotify : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/jquery.fullPage.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
          <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/jqmath-0.4.3.css">
      <link href="stylesheets/bootstrap.min.css" rel="stylesheet">


      <title>Spotify</title>
    <script src="javascripts/jquery.min.js"></script>
    <script src="javascripts/jquery.fullPage.min.js"></script>
      <script src="javascripts/d3.js"></script>
      <script src="javascripts/d3.min.js"></script>
    
          <script src="javascripts/jqmath-0.4.6.js"></script>
      <script src="javascripts/jqmath-etc-0.4.6.min.js"></script>
      <script src="javascripts/jscurry-0.4.5.js"></script>
      <script src="javascripts/jscurry-0.4.5.min.js"></script>


      <script type="text/javascript">
        $(document).ready(function() {
            /*var divElement = document.getElementById('viz1481423599363');
            var vizElement = divElement.getElementsByTagName('object')[0];
            vizElement.style.width = '1004px';
            vizElement.style.height = '669px';
            var scriptElement = document.createElement('script');
            scriptElement.src = 'https://public.tableau.com/javascripts/api/viz_v1.js';
            vizElement.parentNode.insertBefore(scriptElement, vizElement);*/

            $('#fullpage').fullpage({
                        autoScrolling: false,
                        fitToSection: false
                    }

            );
            $.fn.fullpage.setAutoScrolling(false)
        });


    </script>

  </head>

  <body>



    <div id="menu">
      <ul>
        <li><a href="#home">Home</a></li>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#datasets1">Data Exploration</a></li>
        <li><a href="#popularity">Playlist Popularity</a></li>
        <li><a href="#audio-analysis">Audio Analysis</a></li>
          <li><a href="#song-similarity">Song Similarity</a></li>
          <li><a href="#playgen">Playlist Generation</a></li>
          <li><a href="#demo">Demo</a></li>
          <li><a href="#conclusion">Conclusions</a></li>
        <li><a id="forkme_banner" href="https://github.com/spotify-iacs/capstone">View on GitHub &nbsp &nbsp &nbsp &nbsp</a></li>
      </ul>
    </div>

    <div class="spacer">
        &nbsp;
    </div>

    <div id="fullpage">

        <!-- HEADER -->

        <div class="section" id="home">
            <div style="width: 50%; margin-top: 80px; float: left" id="left">
                <br>
                <br>
              <h1>Creating the <br> Perfect Playlist: </h1>
                <h3 style="margin-bottom: 30px">Optimizing Playlist Selection & Sequencing on Spotify</h3>
                <h4>Laura Ware, Sonu Mehta, Omar Abboud</h4>
              <!--<img src="images/Amazon-yellow-arrow.png">-->
                <br>
                <br>
                <a id = 'begin' href="#overview">BEGIN</a>

            </div>
            <div style="width: 50%; float: right; height: 649px" id="right"><div id="force" style="width: 100%; height: 100%"></div></div>


        </div>
        <div id="overview">
          <h2 class="sectiontitle">Overview & Motivation</h2>

            <div class="col-md-6 column">

                                <h3>Introduction</h3>
                <p>
                    In fulfilling its mission to grant people all over the world access to the music they love,
                    Spotify has developed a number of innovative technologies. <strong>Playlists </strong>in particular
                    are an effective vehicle by which Spotify relays and recommends tracks to millions of users. While
                    most playlists on the platform are generated by users themselves, Spotify-curated playlists are
                    amongst the most popular, being followed in some cases by millions users. These playlists are created
                    through a combination of algorithmic and human-driven processes. These playlists are both personalized
                    (such as the esteemed Discover Weekly playlist) as well as intended for general browsing based
                    on genres, moods, or even current events.
                </p>

                <p>
                    This capstone project aims to answer the following question: to what extent can we predict the success
                    of a Spotify-curated playlist, based only on the songs that comprise that playlist? Do the intrinsic
                    features of a song, from it acoustic properties to its relative position within a playlist, contribute
                    to how well users will respond to that playlist? <br>
                </p>

                <p>
                    More specifically, our project aims to develop a predictive model of playlist success that can be used
                    to generate playlists algorithmically, given an optimization function, a sampling algorithm
                    from Spotify's universe of tracks and artists, and only one input song of interest from which to
                    seed the playlist.
                </p>
              
            </div>
            <div class="col-md-6 column">


                <h3>Data Source</h3>
                <p> The primary cata source used for this project was the publicly available <strong>Spotify Api</strong>.
                 From the API, we obtained valuable information about playlists, from their lengths and popularities to
                their component songs and a list of Spotify-derived audio features for each track. For this project we
                analyzed <strong>2,000 playlists</strong> that have been individually curated by Spotify, encompassing a universe of roughly
                <strong>20,000 songs</strong>.</p>

                <h3>Project Features</h3>
                <p>
                    Our project is divided into the following broad spheres of analysis:
                </p>
                <ul>
                    <li>Deciding on a suitable metric for popularity</li>
                    <li>Developing a per-song training set of features from the Spotify API to predict the popularity of
                    any given playlist (or collection of tracks)</li>
                    <li>Deriving our own audio features using sophisticated signal processing and feature extraction techniques</li>
                    <li>Using Spotify's and our own features to generate similarity metrics that can optimize the creation
                    of a new, popular playlist given an input song of interest</li>

                </ul>


            </div>


        </div>

        <div class="section tableauarea" id="datasets1">
            <h2 class="sectiontitle" id="sectiontitletableau">Data Exploration and Visualization</h2>
            <center><p class = 'collabbox'>This carousel cycles through primary observations learned through the data exploration phase of the
            project, such as understanding the relationship between the mean popularity of a playlist's tracks and the overall popularity
                of a playlist.</p></center>
            <div class="slide" id="slide1">
                <center><div class='tableauPlaceholder' id='viz1493651712397' style='position: relative'><noscript><a href='#'><img class="center-image" alt='Spotify has 1726 playlists, but only a few with millions of followers. ' src='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;sp&#47;spotify_api_data_exploration&#47;Dashboard1&#47;1_rss.png' style='border: none' /></a></noscript><object class='tableauViz'  style='display:none;'><param name='host_url' value='https%3A%2F%2Fpublic.tableau.com%2F' /> <param name='site_root' value='' /><param name='name' value='spotify_api_data_exploration&#47;Dashboard1' /><param name='tabs' value='no' /><param name='toolbar' value='yes' /><param name='static_image' value='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;sp&#47;spotify_api_data_exploration&#47;Dashboard1&#47;1.png' /> <param name='animate_transition' value='yes' /><param name='display_static_image' value='yes' /><param name='display_spinner' value='yes' /><param name='display_overlay' value='yes' /><param name='display_count' value='yes' /></object></div>                <script type='text/javascript'>                    var divElement = document.getElementById('viz1493651712397');                    var vizElement = divElement.getElementsByTagName('object')[0];                    vizElement.style.width='1104px';vizElement.style.height='669px';                    var scriptElement = document.createElement('script');                    scriptElement.src = 'https://public.tableau.com/javascripts/api/viz_v1.js';                    vizElement.parentNode.insertBefore(scriptElement, vizElement);                </script></center>
            </div>
            <div class="slide" id="slide2">
                <center><div class='tableauPlaceholder' id='viz1493651656522' style='position: relative'><noscript><a href='#'><img class="center-image" alt='Number of playlist tracks and mean popularity of a playlist&#39;s tracks may be (weak) predictors of playlist popularity ' src='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;sp&#47;spotify_api_data_exploration&#47;Dashboard2&#47;1_rss.png' style='border: none' /></a></noscript><object class='tableauViz'  style='display:none;'><param name='host_url' value='https%3A%2F%2Fpublic.tableau.com%2F' /> <param name='site_root' value='' /><param name='name' value='spotify_api_data_exploration&#47;Dashboard2' /><param name='tabs' value='no' /><param name='toolbar' value='yes' /><param name='static_image' value='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;sp&#47;spotify_api_data_exploration&#47;Dashboard2&#47;1.png' /> <param name='animate_transition' value='yes' /><param name='display_static_image' value='yes' /><param name='display_spinner' value='yes' /><param name='display_overlay' value='yes' /><param name='display_count' value='yes' /></object></div>                <script type='text/javascript'>                    var divElement = document.getElementById('viz1493651656522');                    var vizElement = divElement.getElementsByTagName('object')[0];                    vizElement.style.width='1104px';vizElement.style.height='669px';                    var scriptElement = document.createElement('script');                    scriptElement.src = 'https://public.tableau.com/javascripts/api/viz_v1.js';                    vizElement.parentNode.insertBefore(scriptElement, vizElement);                </script>            </div></center>
            <div class="slide" id="slide3">
                <center><div class='tableauPlaceholder' id='viz1493651616471' style='position: relative'><noscript><a href='#'><img class="center-image" alt='The date a playlist was added seems to have a significant relationship with number of playlist followers. ' src='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;sp&#47;spotify_api_data_exploration&#47;Dashboard3&#47;1_rss.png' style='border: none' /></a></noscript><object class='tableauViz'  style='display:none;'><param name='host_url' value='https%3A%2F%2Fpublic.tableau.com%2F' /> <param name='site_root' value='' /><param name='name' value='spotify_api_data_exploration&#47;Dashboard3' /><param name='tabs' value='no' /><param name='toolbar' value='yes' /><param name='static_image' value='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;sp&#47;spotify_api_data_exploration&#47;Dashboard3&#47;1.png' /> <param name='animate_transition' value='yes' /><param name='display_static_image' value='yes' /><param name='display_spinner' value='yes' /><param name='display_overlay' value='yes' /><param name='display_count' value='yes' /></object></div>                <script type='text/javascript'>                    var divElement = document.getElementById('viz1493651616471');                    var vizElement = divElement.getElementsByTagName('object')[0];                    vizElement.style.width='1104px';vizElement.style.height='669px';                    var scriptElement = document.createElement('script');                    scriptElement.src = 'https://public.tableau.com/javascripts/api/viz_v1.js';                    vizElement.parentNode.insertBefore(scriptElement, vizElement);                </script>            </div></center>
            <div class="slide" id="slide4">
                <center><div class='tableauPlaceholder' id='viz1494616907419' style='position: relative'><noscript><a href='#'><img alt='Dashboard 2 ' src='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;ac&#47;acoustic_similarity_exploration&#47;Dashboard2&#47;1_rss.png' style='border: none' /></a></noscript><object class='tableauViz'  style='display:none;'><param name='host_url' value='https%3A%2F%2Fpublic.tableau.com%2F' /> <param name='site_root' value='' /><param name='name' value='acoustic_similarity_exploration&#47;Dashboard2' /><param name='tabs' value='no' /><param name='toolbar' value='yes' /><param name='static_image' value='https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;ac&#47;acoustic_similarity_exploration&#47;Dashboard2&#47;1.png' /> <param name='animate_transition' value='yes' /><param name='display_static_image' value='yes' /><param name='display_spinner' value='yes' /><param name='display_overlay' value='yes' /><param name='display_count' value='yes' /></object></div>                <script type='text/javascript'>                    var divElement = document.getElementById('viz1494616907419');                    var vizElement = divElement.getElementsByTagName('object')[0];                    vizElement.style.width='904px';vizElement.style.height='569px';                    var scriptElement = document.createElement('script');                    scriptElement.src = 'https://public.tableau.com/javascripts/api/viz_v1.js';                    vizElement.parentNode.insertBefore(scriptElement, vizElement);                </script>
                </center>
            </div>
        </div>


        <div id="popularity">
         <h2 class="sectiontitle">Predicting Playlist Popularity</h2>
            <center><p class='collabbox'>This section describes a series of models that predict the popularity of a playlist,
            defined as the number of playlist followers binned into 5 popularity levels based on quantile. The
                inputs to this model include various attributes relating to the playlist as well as its
            component songs. As the number of songs per playlist varies, summary metrics were decided upon and tested
            in order to generate a final array of playlist-level features that could be used for a suitable prediction.</p></center>
            <!-- <div style="height: 600px"> -->
              <div class="col-md-6 column">

                  <h3>Subset 1: Song-Level Data</h3>
                  <p>The Spotify API provides a number of important data points on the track level, namely the popularity of
                  the track on an index basis from 1 to 100, as well as the number of markets the song is available in. The API
                  also notably includes the following audio-based features per song: acousticness, danceability, duration,
                  energy, instrumentalness, key, liveness, loudness, mode, tempo, valence, and time signature.</p>

                  <h3>Subset 2: Playlist-Level Data</h3>

                  <p>Playlist-level data includes three primary metrics: the number of followers (in other words, the
                  <strong>response variable </strong>we are trying to predict), the number of tracks that are in the playlist,
                      and an indicator corresponding to whether the playlist is featured or not.</p>

                  <h3>Generating a Training Set</h3>

                  <p>
                      One important observation that guided our modeling approach for playlist popularity prediction
                      was the understanding that the mean popularity of a playlist's tracks were a rough proxy or
                      independently strong predictor of popularity. In order to improve upon the predictive ability of an
                      all-encompassing model, however, our goal was to determine whether the addition of acoustical
                      features to a training set would improve the classification rate of a predictive model.<br>
                  </p>
                  <p>
                      In order to generate a training set of playlist-level features, a careful consideration of track-level
                      analysis had to be made in order to aggregate song data in a meaningful way. While simple averaging or
                      addition could have been a simple solution, capturing the distribution of acoustic features more
                      precisely should contain better predictive ability. As a result, our approach was to first
                      approximate the distribution of acoustic features by representing each acoustic features in 5 different
                      columns, each corresponding to the quantile of that feature's distribution across the playlist. The
                      second, and chosen, approach was to instead reflect the distribution through sequencing, by providing
                      the median value of that acoustic feature for songs that belong to a particular quartile of the
                      playlist's progression.
                  </p>

              </div>
              <div class="col-md-6 column">

                  <h3>Baseline Model: Results</h3>

                  <p>Various models were tested for predicting playlist popularity, including logistic regression, support vector machines,
                      and random forest classifiers. The best performing model was a random forest whose overall accuracy was
                      78% on a training set when both acoustic features and metadata were included.</p>

                  <center><img style="width: 70%; display: block" src="images/sketch1.png"/></center>

                  <h3>Final Model: Results</h3>

                  <p>After implementing a rigorous regime of training and testing with cross-validation and tuning,
                  the best performing model was also a random forest classifier of depth 29. While the training set
                  was classified with almost perfect accuracy, results on an out-of-bag testing sample were roughly
                  50%, indicating a rare case of overfitting within the random forest. </p>

                  <img style="width: 80%; display: block" src="images/tuning_rf@3x.png"/>

                  <p></p>
              </div>
        </div>
  <div id="audio-analysis">
            <h2 class="sectiontitle">Raw Audio Analysis</h2>
            <div class="col-md-6 column">

                <h3>Raw-audio Feature Extraction</h3>

                <p>As part of our dataset, we have 30 second raw-audio samples for 15k songs. We extracted 34 acoustic features from raw-audio at each second using a
                    feature extraction library available <a href = "https://github.com/tyiannak/pyAudioAnalysis/wiki/3.-Feature-Extraction">here</a>
                    The acoustic features include 13 Mel Frequency Cepstral Coefficients(MFCC) , 12 Chroma coefficients in addition to energy and other spectral features.
                    These features are a characteristic of the frequency and pitch of the songs. Combining all the 34 features taken at 30 timestamps of a song make 1020
                    dimensional predictor for a song.

                <img src="images/energy_extracted@3x.png" style="width: 65%"/>
                <p> Extraction of energy from track with frame rate = 1 second</p>

                </p>





            </div>
            <div class="col-md-6 column">

            <h3>Predicting track popularity</h3>
            <p>This section describes modelling techniques used to predict the popularity of a track given the raw-audio features.</p>
                <p>The predictors are the mean value of the individual raw-audio features extracted at 30 timestamps and the response is the track popularity
                (in range 0-100)  available from spotify api. Dimensionality reduction techniques like PCA did not give improvement in model performance
                so, we decided to take the mean value of each feature.</p>
                <ol>
                <li><strong>Regression Model: </strong>Regression models like linear regression , GAMs(Generalized additive models) and Random Forest Regressors
                were implemented and the best model was Random Forest Regression with R2 = 0.35. Since the regression models do not perform well, we changed the
                problem to a classification problem by binning the response variable in 6 bins. The songs of low popularity (0-50) were put in bin 1, bin 2
                contains songs of popularity 50-60 and so on.</li>
                    <li><strong>Classification Model: </strong>
                    Random Forest Classification Model turned out to be the best classifier out of different classifiers with cross-validation classification accuracy
                    of 76%. More importantly, the class of the most popular songs has F-score=1(precision =1, recall =1) ,i.e., the most popular class has zero
                    misclassification rate.  The dataset was skewed, with a lot more low popularity songs compared to high popularity songs. Class weights were used to tackle
                    imbalanced dataset.</li>
                </ol>
            </div>
        </div>

        <div class="section" id="song-similarity">
            <h2 class="sectiontitle">Acoustic Similarity</h2>
            <center><p class='collabbox'>The traditional approach technique of determining acoustic similarity is by hand. But this is infeasible for
            large quantities of music. Some researchers have tried to analyize MIDI music data to find melody contour for each
            part of music. But the type of music similarity required for playlist construction is based on the overall sound of 
            music rather than just the melody. One of such approaches is to use the indexing based on matching features such as
            Mel-frequency cepstral coefficients(MFCCs), Chroma coefficients and energy etc. For this project, we used the following 
            two metrics to get acoustically similar songs.</p></center>
            <!--<div class="slide" id="slide1">-->
                <div class="col-md-6 column">
                    
                    <h3>Earth Movers Distance</h3>
                    The EMD calculates the minimum amount of ‘work’(probability mass) required to transform one spectral signature
                    into the other.
                    <p></p>
                     <p><strong>Obtaining the spectral signature</strong></p>
                    
                    <p>The spectral signature attempts to capture the main statistics of the freqeuncy and chroma coefficients
                    to characterize the main types of sounds present in a track. We achieve this by dividing each song into 
                    30 frames each of 1 second.
                    <ol><li>For each frame, we extract 34 acoustic features which consists of 13 MFCCs,
                    12 Chroma coefficents in addition to other spectral and energy features.
                    <li>Once we have these frames, we use Gaussian Mixture Models based clustering to cluster them into 4 clusters for each song. 
                    <p>It is important to note that the clustering is local to each song.
                    The clusters are characterized by means, covariances and weights( weight is proportional to the no. of frames
                    present in each cluster). The set of clusters define the signature of a song. Mathematically, 
                    $\{(&#956_{p_1}, &#931_{p_1}, w_{p_1}),.....(&#956_{p_m}, &#931_{p_m}, w_{p_m})\}$ is the signature of a song
                    where $&#956_{p_1}$ and $&#931_{p_1}$ are the mean and covariance respectively of the cluster $p_i$ and $w_i$ is the weight of that cluster.
                    </p>
                    </p>
                    </ol>
                    <center>Process to obtain signature of song</center>
                    <p>
                    <center><img src="images/signature2.png" style="width: 50%"/></center>
                    
                    </p>
                    



                </div>
                <div class="col-md-6 column">
                    <h3></h3>
                    <strong>Finding song similarity </strong>
                    <p>Once we have the spectral signature of two songs, we use EMD to calculate the similarity between songs.
                    We use symmetric form of KL divergence to calculate the distance between two clusters. Linear programming
                    is used to minimize the cost (defined by multiplying flow with KL divergence distance). Finally EMD is calculated
                    as weighted sum of distances between clusters where weights are flow(probability mass). The lower the EMD value,
                    the more the similarity between songs.                    
                    
                    
                    <p><strong>Optimize song search </strong></p>
                    <p>We have a database of around 15000 songs with their spectral signature. Given a track, its computationally expensive
                    to calculate its EMD from the entire database of songs. To optimize the search process, we use vantange points
                    method. The database of songs is clustered into 10 clusters using Kmeans clustering and the cluster centres are
                    chosen as vantange points. Given an input track, we find the closest vantange point and then return top 200  acoustically
                    similar songs from that cluster (where acoustic similarity is calculated using EMD).
                    This reduces the computation of EMD to a subset of songs.</p>
                    
                    <p>
                    <center><img src="images/vantagepoint.png" style="width: 100%"/></center>
                    
                    </p>
                <h3>Manhattan Distance</h3>
                Calculating EMD between two songs a computationally expensive. In addition to that, raw-audio is required to 
                get the spectral signature. To deal with computational complexity, we used Manhattan distance to calculate song similarity.
                Instead of using raw-audio features, we used acoustic features provided by spotify api as a feature set for the song.
                We used this distance metric to get a list fo acoustically similar songs  from related artists.
                
            
                </div>
                
            <!--</div>-->
        </div>

      

        <div class="section" id="playgen">
          <h2 class="sectiontitle">Playlist Generation</h2>


            <div class="col-md-6 column">
                <h3>Algorithm Overview</h3>

                <img src="images/algorithm_3@3x.png" style="width: 80%"/>

                <!--
                <ul>
                    <li><strong>Step 1: </strong>
                    From a seed track, find related tracks to be candidates for the final output playlist. These candidate tracks fall into three different categories of tracks:
                        <ol>
                            <li><strong>Top tracks from Spotify-defined related artists</strong></li>
                            <li><strong>Tracks from related artists identified as acoustically similar</strong> to the seed song. Acoustic similarity is found using the manhattan distance and Spotify API features.</li>
                            <li><strong>Tracks from a separate database of tracks identified as acoustically similar</strong> to the seed song. Acoustic similarity is found using vantage points and Earth mover's distance.</li>

                        </ol>
                    <li><strong>Step 2: </strong>
                    Select candidate songs from one or more of the above categories. Categories can be weighted to include different proportions of songs from each category.
                </li>
                    <li><strong>Step 3: </strong>
                    Randomly sample 30 tracks from the candidate tracks and optimize the number of playlist followers using our predictive model and simulated annealing. The loss function is defined as a weighted average between class 4 and 5 probabilities--i.e., the playlist has a high probability of falling into the top two quantiles for number of followers. Run four optimizations in parallel and select the best result.
                    </li>
                    <li><strong>Step 4: </strong>
                    Output a final playlist that is predicted to be most successful.
                    </li>
                </ul>

-->

            </div>



            <div class="col-md-6 column">
                <h3>Results</h3>
                <p> As well as selecting one bucket of candidate songs, our implementation allows the user to select
                    multiple buckets and <strong>input a weighting to define the proportions of each bucket</strong> included in the
                    candidate list. We can understand the effects of using different buckets by varying the weights.
                    For example, if we select tracks from both A) top tracks by related artists as well as B) acoustically
                    similar tracks from related artists, we can observe that increasing the proportion of top tracks
                    will give us somewhat better results for the track Shape of You by Ed Sheeran.</p>
                <p> However, using a higher proportion of top tracks will also prevent the final playlist from including
                    songs that are acoustically similar to the seed song, and will limit the addition of new or undiscovered music
                    that may be unlikely to appear in top tracks from related artists.</p>


                <center><img src="images/Asset%204@3x.png" style="width: 60%"/></center>


            </div>
        </div>

            <div class="section" id="optimization">
                <h2 class="sectiontitle">Playlist Optimization: Simulated Annealing</h2>
                <div class="col-md-6 column">
                    <h3>Overview</h3>
                    <p>In order to return the playlist that maximizes the number of followers, we optimize the set and
                    order of tracks using simulated annealing, an optimization technique for estimating the global
                    optimum of a function.</p>
                    <p><a href="#appendixSA">See Appendix A for more detailed background about simulated annealing.</a></p>

                    <h3>Implementation</h3>
                    <p>We begin by initializing four simulated annealing processes in parallel. For each process:</p>
                    <ol>
                        <li>Based on the selected list of candidate tracks and the desired annealing duration,
                            tune the parameters and initialize
                            the number of steps and initial and final temperature. </li>
                        <li>Initialize the state (playlist chosen randomly without replacement from the list of candidate tracks).</li>
                        <li>Perform L steps:
                            <ul>
                                <li>Propose a new state (playlist) by swapping out one track with a different track in the candidate list</li>
                                <li>Measure the predicted class probabilities for number of followers using the trained random
                                    forest classifier, and calculated the new energy. If the energy decreases, accept
                                    the change. If the energy increases, accept or deny the change if $e^{{ΔE}{T^{-1}}}< r$, where r is a random variable between 0 and 1.
                                    If the swap is accepted, set $x_{i+1}=x_j$, else return to the old state.</li>
                            </ul>
                        </li>
                        <li>Until the defined number of steps, return to step 3 and propose and new swap.</li>
                        <li>After the four processes complete, select the result with the lowest final energy.</li>
                    </ol>
                    <p><strong>Cost Function: </strong>We define our cost (energy) $E$ as $10^4 *(1-(0.25P_4+0.75P_5))$,
                        where $P_j$ is the class (pseudo) probability of that the playlist is in class $j$</p>

                </div>
                <div class="col-md-6 column">

                    <h3>Results</h3>
                    <p>Simulated annealing effectively lowers the energy, plateauing after several hundred transitions. </p>
                    <center><img src="images/sim_annealing_energy_plateau_2@3x.png" style="width: 45%"/></center>
                    <p>Optimization performance is significantly better than the baseline of random sampling, resulting in substantially
                        higher probabilities for classes 4 and 5 (top two classes).</p>
                    <center><img src="images/sim_annealing_bar_chart@3x.png" style="width: 60%"/></center>


                </div>
            </div>

        <div class="section" id="demo">
            <h2 class="sectiontitle">Interactive Playlist Demonstration</h2>

            <!--center><p id='playbox' class='collabbox'>In this section, you can interact with the playlist generation model by selecting
            an input song from the options on the left and the type of method utilized to optimize for playlist popularity.
            After selecting these parameters, an output playlist will be displayed with the corresponding class probabilities
            predicted by the model for popularity levels 1 through 5.</p></center>-->

            <div class="col-md-6 column" style="height:600px">

                <h3>1. Select Seed Song</h3>

                <div class="select-song" style="height:40%;">

                   <!-- <iframe src=\"https://open.spotify.com/embed?uri=spotify:track:7qiZfU4dY1lWllzX7mPBI3\"frameborder=\"0\" allowtransparency=\"true\"></iframe>
-->
                    <table id="songselect">
                        <tr>
                            <th class="first">Song Name</th>
                            <th class="second">Artist</th>
                            <th class="third">Preview</th>
                        </tr>

                        <tr class="input-song selection" id="7qiZfU4dY1lWllzX7mPBI3">
                            <td class="input-song first">Shape of You</td>
                            <td class="input-song second">Ed Sheeran</td>
                            <td class="input-song third">
                            <iframe style="background: #FFFFFF" src="https://open.spotify.com/embed?uri=spotify:track:7qiZfU4dY1lWllzX7mPBI3&theme=black&view=list"
                                    width="80" height="80" frameborder="0" allowtransparency="true"></iframe></td>
                        </tr>
                        <tr class="input-song selection" id="6txo4X8yd8FekwFFtI82Ea">

                            <td class="input-song first">Piano Sonata No. 14 in C Minor</td>
                            <td class="input-song second">Mozart</td>
                            <td class="input-song third">
                            <iframe src="https://open.spotify.com/embed?uri=spotify:track:6txo4X8yd8FekwFFtI82Ea&theme=white&view=coverart"
                                    width="80" height="80" frameborder="0" allowtransparency="true"></iframe></td>
                            <!--<td>6txo4X8yd8FekwFFtI82Ea</td>-->
                        </tr>
                        <tr class="input-song selection" id="7k2lqQ4Vt9435X24qUISki">
                            <td class="input-song first">Daydream</td>
                            <td class="input-song second">Ciele (ft. Chris Ho)</td>
                            <td class="input-song third">
                                <iframe src="https://open.spotify.com/embed?uri=spotify:track:7k2lqQ4Vt9435X24qUISki&theme=white&view=coverart"
                                        width="80" height="80" frameborder="0" allowtransparency="true"></iframe></td>
                            <!--<td>7k2lqQ4Vt9435X24qUISki</td>-->
                        </tr>
                    </table>

                </div>

                <h3 id="category-select">2. Select Category of Candidate Songs</h3>

                <div class="select-type" style="height:50%;">

                    <table id="methodselect">
                        <tr>
                            <th>Method</th>
                        </tr>
                        <tr id="Top tracks from related artists">
                            <td>Top Tracks From Related Artists</td>
                        </tr>
                        <tr id="Similar tracks from related artists">
                            <td>Similar Tracks From Related Artists</td>
                        </tr>
                        <tr id="Similar tracks from vantage point database">
                            <td>Similar Tracks From Vantage Points Database</td>
                        </tr>
                    </table>


                </div>
            </div>


            <div class="col-md-6" style="height: 600px">

                <h3>3. View Playlist & Class Probabilities</h3>

                <div class="playlist-gen" style="height:50%;">

                    <table>

                        <thead>

                        <tr>
                            <th class="playlist-col">Recommended Playlist</th>
                            <th class="popularity-col">Popularity</th>
                            <!--
                            <th>Track #</th>
                            <th>Song Name</th>
                            <th>Artist</th>
                            <th>Song ID</th>-->
                        </tr>
                        </thead>
                        <tbody class="play">
                        <!--
                        <tr>
                            <td>1</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>9</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>10</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>11</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>12</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>13</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>14</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>15</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>16</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>17</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>18</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>19</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>20</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>21</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>22</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>23</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>24</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>25</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>26</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>27</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>28</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>29</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>30</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>-->
                        </tbody>
                    </table>

                </div>
                <div id="chart-area" style="margin-top: 30px;"></div>
            </div>
        </div>

        <div style="height:450px" id="conclusion">
            <h2 class="sectiontitle">Conclusions & Future Work</h2>
            <div class="col-md-6 column">
              <h3>Conclusions</h3>

                <p>Playlists can be optimized for popularity using
                  acoustic and non-acoustic features extracted from component songs. Non-acoustic features include
                  the song's popularity, its availability in world markets, and other metadata obtained from the record
                  summary. Acoustic features include prescribed signals for energy, liveliness, tempo, and key, with
                  additional features engineered and sampled by us. </p>

               <p>
                  Generating a playlist given an input song of interest was performed using simulated annealing,
                   which optimized combinations and sequences of songs across a pool of candidate tracks. Our final
                   module allows a user to specify the pool of candidate songs from a list of three options:
                   a network of top tracks from related artists, a network of similar tracks from related
                   artists, or a system of similar tracks that are 100% acoustically-derived from across the Spotify
                   universe.
               </p>
              <h3>Future Work</h3>
              <p>
                  We recommend two areas of future research: first, steps must be taken to mitigate the rare case
                  of overfitting that affected our random forest classifier, which over-predicted unpopular playlists
                  in the testing set. Second, more metadata must be collected and then incorporated as predictors of
                  popularity to ensure that acoustical features are not capturing information such as release date or
                  other non-intrinsic characteristics.
              </p>
          </div>
            <div class="col-md-6 column">
                <h3>Challenges</h3>
                <p> Evaluating recommendation systems is always tricky, as
                    there is often no definite metric to measure acoustic similarity. This problem is usually approached
                    in a subjective way, whereby music experts rate the similarity of songs and finally the majority
                    vote is taken to generate similarity scores between songs. Based on literature review, we found
                    that songs we deemed to be acoustically similar belonged to the same genre more that 90% of the time.
                    To further evaluate our model for acoustic similarity, we listened to the songs ourselves and noted
                    striking similarities in the acoustics, singing style, and genre.</p>
                <p> Evaluating our playlist generation engine is also challenging for two primary reasons.
                    <ol>
                <li>We have a limited dataset of ~1700 playlists, and only 25% of the songs present in those playlists
                    included raw audio available for us to analyze.</li>
                <li>
                    Part of our goal was to incorporate songs into successful playlists that belonged to lesser-known
                    artists, which accounts for about 25% of our data. Our loss function, however, accounted only
                    for overall playlist popularity and didn't penalize for popular or unpopular songs within the playlist.
                </li>
                    </ol>
                </p>

            </div>
        </div>

        <div id="appendixSA">
            <h2 class="sectiontitle">Appendix A: Simulated Annealing</h2>
            <div class="col-md-6 column">

                <h3>Background</h3>

                <p>
                    Simulated Annealing is one of the most popular techniques for global optimization.
                    The technique is based on the physical annealing process, in which a system is first heated
                    to a melting state and then cooled down slowly.
                    When the solid is heated, its molecules start moving randomly, and its energy increases.
                    If the subsequent process of cooling is slow, the energy of the solid decreases slowly,
                    but there are also random increases in the energy governed by the Boltzmann distribution.
                    If the cooling is slow enough, and deep enough to unstress the solid, the system will
                    eventually settle down to the lowest energy state where all the molecules are arranged
                    to have minimal potential energy.
                </p>

                <p>
                    Suppose the system is in a state with energy $E_i$ (function at current $x_i$ has value $E_i$)
                    and subsequent to the random fluctuation to position $x_j$, now has energy state $E_j$.
                    We denote the change in the energy due to the state change as $ΔE=E_j−E_i$.
                    The move to the new position $x_j$ is done via a proposal. If the new state has lower
                    energy than the current state, we go into this new state. This stochastic acceptance
                    of higher energy states, allows our process to escape local minima.

                </p>

                <p>
                    As the temperature is lowered, there will be more concentrated search effort near
                    the current local minimum, since only few uphill moves will be allowed. Thus,
                    if we tune our temperature decrease schedule appropriately, we hope to converge to a
                    global minimum. If the lowering of the temperature is sufficiently slow,
                    the system reaches “thermal equilibrium” at each temperature.
                </p>


            </div>
            <div class="col-md-6 column">

                <h3>Algorithm</h3>

                <ol>
                    <li>Initialize the state $xi$, temperature $T$, $L(T)$ where $L$ is the number of iterations at a particular temperature.</li>
                    <li>Perform L transitions thus (we will call this an epoch):
                        <ol>
                            <li>Generate a new proposed position x</li>
                            <li>If $x$ is accepted (according to probability $P=e^{{ΔE}d{T}}$), set $x_{i+1}=x_j$, else set $x_{i+1}=x_i$.</li>
                        </ol>
                    </li>
                    <li>Update $T$ and $L$</li>
                    <li>Until some fixed number of epochs, or until some stop criterion is fulfilled, return to step 2.</li>
                </ol>


                <p> <strong>Hill Climbing with Simulated Annealing</strong></p>
                By <a href="//commons.wikimedia.org/wiki/User:Kingpin13" title="User:Kingpin13">Kingpin13</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="http://creativecommons.org/publicdomain/zero/1.0/deed.en" title="Creative Commons Zero, Public Domain Dedication">CC0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=25010763">Link</a>
                <center><img src="images/Hill_Climbing_with_Simulated_Annealing.gif" style="width: 100%"/></center>

            </div>
        </div>



        <div id="references">
            <h2 class="sectiontitle">References</h2>
            <div class="col-md-12 column">
            <ol>
                <li>

                    Berenzweig, Adam, Beth Logan, Daniel P.W. Ellis, & Brian Whitman. A Large-Scale Evaluation of Acoustic and Subjective Music Similarity Measures. Proceedings of the ISMIR International Conference on Music Information Retrieval (Baltimore, MD), 2003, pp. 99–105.

                </li>
                <li>
                    Logan, B., “A Content-Based Music Similarity Function,” (Report CRL 2001/02) Compaq Computer Corporation Cambridge Research Laboratory, Technical Report Series (Jun. 2001).

                </li>
                <li>Charu C. Aggarwal, Alexander Hinneburg, and Daniel A. Keim. 2001. On the Surprising Behavior of Distance Metrics in High Dimensional Spaces. In Proceedings of the 8th International Conference on Database Theory (ICDT '01), Jan Van den Bussche and Victor Vianu (Eds.). Springer-Verlag, London, UK, UK, 420-434.</li>
                <li>
                    Dave, R., “Simulated Annealing,” AM207: Stochastic Optimization & Monte Carlo Methods for Data Analysis and Inference, Harvard University. Course Website (accessed 05/09/2017). https://am207.github.io/2017/wiki/simanneal.html.
                </li>
            </ol>

            </div>

        </div>
          <footer>
            <br>
            <br>
            <center><a id = 'end' href="#home">HOME</a></center>
        </footer>
        
    </div>
  </body>

  <script src="javascripts/playlist.js"></script>
  <script src="javascripts/graph.js"></script>
  <script src="javascripts/queue.v1.min.js"></script>
<script src="javascripts/bootstrap.min.js"></script>
<script src="javascripts/main.js"></script>
<script src="javascripts/jquery.fullPage.min.js"></script>





</html>
